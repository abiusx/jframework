<?php


/*
 * Concepts:
 * A CSR contains a public key and a distinguished name
 * A key (or PrivateKey) contains a private key and a public key, generated by config args
 * A PublicKey contains only a PublicKey
 * A X509 contains whatever a CSR has + a signature provided by another X509 (or self!),
 * 	so you need the PrivateKey of another X509 to sign this with that.
 * All of the resources can be of the form PEM (ASCII Encoded)
 * 
 * PKCS #12: the standard to save Certificates and their corresponding Private Keys into a file
 */

/**
 * jPKI Class
 * @author abiusx
 * @version 1.25
 * note that you can extract a public key out of a private key
 * also note that almost always you can use a PrivateKey PEM instead of a PrivateKey (same for public key)
 *
 */
class JpkiCorePlugin extends BasePluginClass
{
	private $ConfigArgs = array ();

	/**
	 * Configures Arguments which are used by a few other functions such as CreateKey
	 *	The last configured arguments are automatically consumed by functions who use ConfigArgs
	 * 
	 * @param String $DigestAlgorithm : md5 , sha1, ...
	 * @param String $X509Extensions
	 * @param String $RequestExtensions
	 * @param Integer $PrivateKeyBits : 384 or more (1024 or 2048 for RSA)
	 * @param Integer $PrivateKeyType : OPENSSL_KEYTYPE_RSA=0 , ...
	 * @param String $EncryptKey
	 * @return ConfigArgs array.
	 * @seealso CreateKey
	 */
	function ConfigureArguments($DigestAlgorithm = null, $X509Extensions = null, $RequestExtensions = null, $PrivateKeyBits = null, $PrivateKeyType = null, $EncryptKey = null)
	{
		$Config = array ();
		if ($DigestAlgorithm) $Config ['digest_alg'] = $DigestAlgorithm;
		if ($X509Extensions) $Config ['x509_extensions'] = $X509Extensions;
		if ($RequestExtensions) $Config ['req_extensions'] = $RequestExtensions;
		if ($PrivateKeyBits) $Config ['private_key_bits'] = $PrivateKeyBits;
		if ($PrivateKeyType) $Config ['private_key_type'] = $PrivateKeyType;
		if ($EncryptKey) $Config ['encrypt_key'] = $EncryptKey;
		return $this->ConfigArgs = $Config;
	}
	
	private $DistinguishedName;

	/**
	 * Creates a DistinguishedName to be used in a CertificateSigningRequest or a X.509_Certificate
	 * This function saves the generated DN as well as returning it, So if you call any functions
	 * which consume a DN and don't provide them with any DN, last saved DN would be used.
	 * 
	 * @param String $CountryName : Two-letter country name, e.g IR
	 * @param String $StateOrPrivinceName
	 * @param String $LocalityName
	 * @param String $OrganizationName
	 * @param String $OrganizationalUnitName
	 * @param String $CommonName : the main name of the DN
	 * @param String $EmailAddress
	 * @return DistinguishedName
	 */
	function CreateDistinguishedName($CountryName, $StateOrPrivinceName, $LocalityName, $OrganizationName, $OrganizationalUnitName, $CommonName, $EmailAddress)
	{
		$dn = array (
			"countryName" => $CountryName, "stateOrProvinceName" => $StateOrPrivinceName, "localityName" => $LocalityName, "organizationName" => $OrganizationName, "organizationalUnitName" => $OrganizationalUnitName, "commonName" => $CommonName, "emailAddress" => $EmailAddress 
		);
		return $this->DistinguishedName = $dn;
	}

	/**
	 * Creates a PrivateKey
	 *
	 * @return PrivateKey
	 * @seealso ConfigureArguments
	 */
	function Key_Create()
	{
		return openssl_pkey_new ( $this->ConfigArgs );
	}

	/**
	 * Extracts private key and returns it as string
	 *
	 * @param PrivateKey $Key
	 * @return String PEM Private Key (This also contains public key)
	 * @seealso CreateKey
	 */
	function Key_ExportPrivate($Key)
	{
		$out = "";
		openssl_pkey_export ( $Key, $out );
		return $out;
	}

	/**
	 * Extracts public key and returns it as string
	 *
	 * @param PrivateKey $Key
	 * @return String PEM Public Key
	 * @seealso CreateKey
	 */
	function Key_ExportPublic($Key)
	{
		$pubkey = openssl_pkey_get_details ( $Key );
		return $pubkey ['key'];
	}

	/**
	 * Converts a private key PEM string to a Key
	 *
	 * @param String $Key PEM Private Key
	 * @return PrivateKey
	 * @seealso CreateKey
	 */
	function Key_ImportPrivate($Key)
	{
		return openssl_pkey_get_private ( $Key );
	}

	/**
	 * Import a public key PEM string to a key
	 *
	 * @param String $Key PEM Public Key
	 * @return PublicKey
	 * @seealso CreateKey
	 */
	function Key_ImportPublic($Key)
	{
		return openssl_pkey_get_public ( $Key );
	}

	/**
	 * Returns bits, (public) key and type of a $Key
	 * @param PrivateKey $Key
	 * @return array ("bits","key","type")
	 */
	function Key_Details($Key)
	{
		return openssl_pkey_get_details ( $Key );
	}

	/**
	 * Extracts public and private key and returns them as string array
	 *
	 * @param PrivateKey $Key
	 * @return Array("Public","Private")
	 * @seealso CreateKey
	 */
	
	function Key_GetPair($Key)
	{
		$privkey = "";
		openssl_pkey_export ( $Key, $privkey );
		$pubkey = openssl_pkey_get_details ( $Key );
		$pubkey = $pubkey ["key"];
		return array (
			"Public" => $pubkey, "Private" => $privkey 
		);
	}

	/**
	 * Creates a CertificateSigningRequest which can be signed by a CA.
	 * If you do not provide optional DistinguishedName, last created DN would be used.
	 * 
	 * @param String $PrivateKey or Key $PrivateKey
	 * @param DistinguishedName $DistinguishedName : Distinguished Name to create request
	 * @return CertificateSigningRequest
	 * @seealso DistinguishedName
	 */
	function CSR_Create($PrivateKey, $DistinguishedName = null)
	{
		if ($DistinguishedName == null) $DistinguishedName = $this->DistinguishedName;
		$CSRequest = openssl_csr_new ( $DistinguishedName, $PrivateKey );
		return $CSRequest;
	}

	/**
	 * Signs a CertificateSigningRequest, producing a X.509 Digital Certificate
	 *
	 * @param CertificateSigningRequest $CSR : the request to be signed
	 * @param String $PrivateKey or Key $PrivateKey the private key of the issuer to sign with (self private key for self sign)
	 * @param X.509 $IssuerCertificate : the parent certificate, if not set, self-signed
	 * @param Integer $Days : total number of days certificate would be valid
	 * @param String $Serial
	 * @return X.509
	 */
	function CSR_Sign($CSR, $IssuerPrivateKey, $IssuerCertificate = null, $Days = 365, $Serial = null)
	{
		$X509 = openssl_csr_sign ( $CSR, $IssuerCertificate, $IssuerPrivateKey, $Days, $this->ConfigArgs, $Serial );
		return $X509;
	}

	/**
	 * Extracts PublicKey from a CertificateSigningRequest
	 * @param CertificateSigningRequest $CSR
	 * @return PublicKey
	 */
	function CSR_PublicKey($CSR)
	{
		return openssl_csr_get_public_key ( $CSR );
	}

	/**
	 * Extracs a DistinguishedName from a CSR
	 * @param CertificateSigningRequest $CSR
	 * @param boolean $ShortNames to return short names as array keys
	 * @return DistinguishedName
	 */
	function CSR_DistinguishedName($CSR, $ShortNames = true)
	{
		return openssl_csr_get_subject ( $CSR, $ShortNames );
	}

	/**
	 * Exports a CertificateSigningRequest to a readable ASCII text-format
	 * @param CertificateSigningRequest $CSR
	 * @return String
	 */
	function CSR_Export($CSR)
	{
		$out = '';
		openssl_csr_export ( $CSR, $out );
		return $out;
	}

	/**
	 * Wraps CSR_Create and CSR_Sign
	 * Use this if you intend to create a X.509 Certificate based on a private key.
	 *
	 * @param DistinguishedName $DistinguishedName
	 * @param String $IssuerPrivateKey PEM or PrivateKey $PrivateKey
	 * @param X.509 $IssuerCertificate
	 * @param Integer $Days : total number of days certificate would be valid
	 * @param String $Serial
	 * @return X.509
	 * @seealso DistinguishedName SignCertificateSigningRequest CreateCertificateSigningRequest
	 * 
	 */
	function X509_Create($DistinguishedName = null, $IssuerPrivateKey, $IssuerCertificate, $Days = 365, $Serial)
	{
		$CSR = $this->CSR_Create ( $IssuerPrivateKey, $DistinguishedName );
		return $this->CSR_Sign ( $CSR, $IssuerPrivateKey, $IssuerCertificate, $Days, $Serial );
	}

	
	/**
	 * Exports a PEM string from the X509 Certificate
	 * @param X509 $X509
	 * @return String PEM
	 */
	function X509_Export($X509)
	{
		openssl_x509_export ( $X509, $out );
		return $out;
	}
	function X509_ExtractPublicKey($X509)
	{
		return openssl_pkey_get_public ( $X509);
	}
	/**
	 * Checks to see if a private key corresponds to a public key inside a certificate
	 * @param X509 $X509
	 * @param String $PrivateKey PEM encoded or Key $PrivateKey
	 * @return Boolean
	 */
	function X509_CheckPrivateKey($X509, $PrivateKey)
	{
		return openssl_x509_check_private_key ( $X509, $PrivateKey );
	}

	/**
	 * Imports a PEM string into a X509 Certificate
	 * @param String $PEM
	 * @return X509
	 */
	function X509_Import($PEM)
	{
		return openssl_x509_read ( $PEM );
	}

	/**
	 * Exports an array of details from a certificate
	 * @param X509 $X509
	 * @param Boolean $ShortNames
	 * @return array
	 */
	function X509_Details($X509, $ShortNames = true)
	{
		
		return openssl_x509_parse ( $X509, $ShortNames );
	}

	/**
	 * Generates a signature of data by computing a hash of it, then encrypting it with the private key
	 * @param String $Data
	 * @param PrivateKey $PrivateKey 
	 * @param Integer $Algorithm optional
	 * @return String the signature of the data (does not contain data itself) 
	 */
	function SignData($Data, $PrivateKey, $Algorithm = OPENSSL_ALGO_SHA1)
	{
		$Signature = "";
		openssl_sign ( $Data, $Signature, $PrivateKey, $Algorithm );
		return $Signature;
	}

	/**
	 * Verifies if a signature belongs to a particular data
	 * @param String $Data
	 * @param String $Signature the signature of the data
	 * @param PublicKey $PublicKey public key corresponding to the private key used for signing
	 * @param Integer $Algorithm optional
	 * @return Boolean (-1 on error)
	 */
	function VerifyDataSignature($Data, &$Signature, $PublicKey, $Algorithm = OPENSSL_ALGO_SHA1)
	{
		return openssl_verify ( $Data, $Signature, $PublicKey, $Algorithm );
	}

	/**
	 * Seals some data which can be unsealed by all of those whose public keys are used here,
	 * a random key is generated and data is encrypted with RC4 and that, then this random key is
	 * encrypted by all those Public Keys, so that every one having one of matching private keys
	 * and the sealed data can read it.
	 * 
	 * @param String $Data
	 * @param mixed $PublicKeys String PEM or Array of strings PEM (or PublicKeys)
	 * @return array( "Data" , "Length" , "EnvelopeKeys"=>array ( PublicKey_Encrypted_Keys ) )
	 */
	function SealData($Data, $PublicKeys)
	{
		if (! is_array ( $PublicKeys )) $PublicKeys = array (
			$PublicKeys 
		);
		$Length = openssl_seal ( $Data, $SealedData, $EncryptedKeys, $PublicKeys );
		return array (
			"Data" => $SealedData, "Length" => $Length, "EnvelopeKeys" => $EncryptedKeys 
		);
	}

	/**
	 * 
	 * @param String $SealedData
	 * @param String $EnvelopeKey the encrypted key (encrypted with our public key)
	 * @param String $PrivateKey PEM or PrivateKey
	 * @return String unsealed data
	 */
	function UnsealData($SealedData, $EnvelopeKey, $PrivateKey)
	{
		openssl_open ( $SealedData, $out, $EnvelopeKey, $PrivateKey );
		return $out;
	}

	/**
	 * Exports the data to be stored in a .p12 file (encrypted certificate and private key)
	 * @param X509 $X509
	 * @param PrivateKey $PrivateKey or PEM
	 * @param String $Password to encrypt the whole file
	 * @return String
	 */
	function PKCS12_Export($X509, $PrivateKey, $Password = "")
	{
		$out = '';
		openssl_pkcs12_export ( $X509, $out, $PrivateKey, $Password );
		return $out;
	}

	/**
	 * Imports the data from a .p12 and returns parts
	 * @param String $PKCS12
	 * @param String $Password
	 * @return array("cert","pkey","extracerts"=>array);
	 */
	function PKCS12_Import($PKCS12, $Password = "")
	{
		$out = '';
		openssl_pkcs12_read ( $PKCS12, $out, $Password );
		return $out;
	}

	function Encrypt_Public($Data, $PublicKey)
	{
		$out = '';
		openssl_public_encrypt ( $Data, $out, $PublicKey );
		return $out;
	}

	function Encrypt_Private($Data, $PrivateKey)
	{
		$out = '';
		openssl_private_encrypt ( $Data, $out, $PrivateKey );
		return $out;
	}

	function Decrypt_Public($Data, $PublicKey)
	{
		$out = '';
		openssl_public_decrypt ( $Data, $out, $PublicKey );
		return $out;
	}

	function Decrypt_Private($Data, $PrivateKey)
	{
		$out = '';
		openssl_private_decrypt ( $Data, $out, $PrivateKey );
		return $out;
	}

}
?>